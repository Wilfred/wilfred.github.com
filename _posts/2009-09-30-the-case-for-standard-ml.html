--- 
layout: post
title: The Case For Standard ML
tags: 
- Essays
---
If you do a computer science degree at Cambridge, your very first taste of programming will be in Standard ML. For quite some time this seemed strange to me, as the merits were never clearly explained. Most students had not even heard of the language, let alone written any code in it. At the time, I assumed that its purpose was to give all the students a level playing field, since no-one seemed to have any SML experience.

However, an interesting discussion ensued when MIT changed from teaching Scheme to Python as a first language for its computer scientists. All of a sudden people were arguing over whether we should teach computer scientists functional programming and the importance of being mainstream. To see the various sides being argued read the discussion on <a href="http://news.ycombinator.com/item?id=602307">Hacker News</a>, <a href="http://www.reddit.com/r/programming/comments/8mfw8/chiming_in_on_the_mit_scheme_to_python_switch/">reddit</a> and <a href="http://lambda-the-ultimate.org/node/1840">Lambda the Ultimate</a>. This prompted me to re-evaluate SML to decide how much value there is in learning the language.
<h3>The strengths of Standard ML</h3>
No language is ideally suited to every task. Since SML is used as a starting language, you may not have many other tools that you are familiar with. This sadly highlights the weaknesses more than SML's strengths. Let us consider situations where SML is a great choice.

SML has a fantastic pattern matching approach to function definitions. Rather than using switch case statements the syntax is minimal and elegant. The result of this is that SML <a href="http://flint.cs.yale.edu/cs421/case-for-ml.html">lends itself to compiler writing</a>. When studying semantics in the second year of the course, <a href="http://www.cl.cam.ac.uk/teaching/0809/Semantics/">code for an interpreter</a> of a toy language is presented in SML and Java. The SML version includes a pretty print function not in the version and is still half the total lines of code.

SML is fundamentally a functional language.  First time programmers will be exposed to (amongst other things) currying, higher order functions and immutable data structures. This is increasingly relevant as functional language are often ideal for writing multithreaded code. A number of popular languages in this area such as F#, OCaml and Clojure have all been influenced by SML, so an SML programmer will find these languages much easier to pick up at a later date.

SML is also unusual in having a complete formal specification. For safety-critical systems or other areas that need formal verification of code, SML allows developers to prove properties of their system. This is still a major area of computer science research. A common alternative to SML is to use a subset of a more mainstream language's features. The advantage SML has here is that its libraries are also valid SML and so verifying the library functions are valid and ensuring the compiler is reliable is a lot easier.
<h3>The importance of evangelism</h3>
SML is sorely lacking people who declare its virtues. There are very few people who blog about the language and very few projects out there for people to play with. Bloggers offer tips, ideas and inspiration to fellow programmers of a language. A single <a href="http://talideon.com/weblog/2008/03/mosml-pt1.cfm">blog post on SML</a> can be full of helpful information. Only through reading material produced by curious programmers was I exposed to <a href="http://talideon.com/weblog/2008/03/mosml-pt1.cfm#cmt23664">using rlwrap to save history</a> and the <a href="http://mlton.org/Emacs">emacs modes available for SML</a>.

As for projects, I was informed that SML is used by the military (presumably due to its formal specification), but this doesn't exactly produce public-facing projects. The only two applications written in SML that I am aware of are <a href="http://atseidl2.informatik.tu-muenchen.de/~berlea/Fxp/">fxp (an XML parser)</a> and <a href="http://mlton.org/Swerve">Swerve (a HTTP server)</a>. Exposure to these projects is a huge encouragement to students.

Whilst SML is failing to evangelise, Objective Caml (OCaml) is much more effective at this. It is a derivative language of SML and so the syntactic differences are slightÂ <a href="http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html">[1]</a><a href="http://hyperpolyglot.org/ml">[2]</a>. One consequence of this is that there are plenty of interesting OCaml projects to experiment with, such as <a href="http://en.wikipedia.org/wiki/Mldonkey">P2P clients</a>, <a href="http://savonet.sourceforge.net/">internet radio</a> and even <a href="http://ocsigen.org/">web frameworks</a>. With such a thriving community I would encourage any SML programmer to explore OCaml.
<h3>Should SML be taught?</h3>
Functional programming is important today and won't be disappearing anytime soon. SML does level the playing field between those who have programmed before and those who haven't. Sadly many of its tools are no longer maintained. There is also very little in the way of a community around the language. However, a good programmer is fluent in a number of languages with different paradigms and at Cambridge he will be exposed to several. SML programmers can move to OCaml or other functional programming languages without too much difficulty.

That being said, if Cambridge moves to another functional language tomorrow I wouldn't consider it a great loss.
