--- 
layout: post
title: "Getting Started With LLVM"
---

_A walkthrough of writing a basic compiler with LLVM. No prior
experience assumed._

LLVM is a great project to work with: the people are friendly, the
docs are good, and the technology itself is excellent. It's a great
tool to get started in compiler writing.

I decided to write a [BF](https://en.wikipedia.org/wiki/Brainfuck)
compiler to explore the API. In spite of a total lack of C++
experience, I was able to develop a bona fide compiler!

The LLVM team provide a great
[tutorial](http://llvm.org/docs/tutorial/index.html) and there is already
a BF compiler in
[LLVM's examples directory](http://llvm.org/viewvc/llvm-project/llvm/trunk/examples/). In
this post, I'll focus on the steps needed to get up and running.

## A first LLVM program

First, we need to write a skeleton LLVM program. You'll want to take a
look at the
[LLVM IR Reference Manual](http://llvm.org/docs/LangRef.html) to get a
feel of how LLVM IR works. However, **you can cheat and have Clang
write the LLVM IR for you**!

For our initial program, we'll just exit with a return code
of 42. This is easy in C:

{% highlight c %}
int main() {
    return 42;
}
{% endhighlight %}

We can generate a `forty_two.ll` file by simply running `clang -S
-emit-llvm -O3 forty_two.c`. We specify `-O3` to avoid getting
redundant instructions in our main function. Our main function now
looks like this:

{% highlight llvm %}
define i32 @main() {
  ret i32 42
}
{% endhighlight %}

Easy! We can use `lli` to run this file:

    $ lli forty_two.ll 
    $ echo $?
    42

## Writing a skeleton

Now we know how to write and run an LLVM IR program, we need to figure
out what LLVM IR we want to generate. We will need to compile the BF
source to LLVM IR instructions.

However, those instruction will need to be inside a skeleton `main`
function so LLVM knows our entry point. We will also need to allocate
and initialise our memory cells and cell index.

Again, it's a matter of writing some basic C and seeing what LLVM IR
is generated by Clang. Here's the skeleton we'll use:

{% highlight llvm %}
declare i8* @calloc(i32, i32)
declare void @free(i8*)

define i32 @main() nounwind {
  ; Allocate 30,000 cells on the heap.
  %cells = call i8* @calloc(i32 30000, i32 1)

  ; Allocate a stack variable to track the cell index.
  %cell_index_ptr = alloca i8
  ; Initialise it to zero.
  store i8 0, i8* %cell_index_ptr

  ;;;;;;;;;;;;;;;;;;;;
  ; Our BF code will go here!
  ;;;;;;;;;;;;;;;;;;;;

  ; Free the memory for the cells.
  call void @free(i8* %cells)
  ret i32 0
}
{% endhighlight %}

## Hand-compiling &gt;

Let's take a look at compiling BF's `>` command, which simply
increments the cell index. LLVM IR is in SSA form, so we can only
assign to each variable once.

{% highlight llvm %}
%cell_index_tmp = load i8* %cell_index
%cell_index_tmp2 = add i8 1, %cell_index_tmp
store i8 %cell_index_tmp2, i8* %cell_index
{% endhighlight %}

This seems correct, but how do we verify it? We can wrap this code in
our skeleton and run it, to ensure it works as expected. You can see
[the full test program here](https://github.com/Wilfred/Brainfrack/blob/5a2f613f9e82bfd57be687aa6a67aca15d3d9861/llvm/increment_data_pointer.ll).

Implementing `<` is straightforwards once we have `>`.

## Hand-compiling +

BF's `+` command increments the cell we're currently looking at. In C,
we'd just write `cells[cell_index]++`. In LLVM IR, we need a pointer
to the cell we want to change. We will need IR to be equivalent to:

{% highlight c %}
char *cell_ptr = cells + cell_index;
char current_value = *cell_ptr;
char new_value = current_value + 1;
*cell_ptr = new_value;
{% endhighlight %}

To calculate a pointer, we need to use the
[getelementptr instruction](http://llvm.org/docs/LangRef.html#getelementptr-instruction). The
translation then looks like this:

{% highlight llvm %}
%cell_index = load i8* %cell_index_ptr
%cell_ptr = getelementptr i8* %cells, i8 %cell_index

%current_value = load i8* %cell_ptr
%new_value = add i8 %current_value, 1
store i8 %tmp2, i8* %cell_ptr
{% endhighlight %}

I've written
[a test program for + too](https://github.com/Wilfred/Brainfrack/blob/5a2f613f9e82bfd57be687aa6a67aca15d3d9861/llvm/increment.ll).

## I/O

BF has two I/O commands. `,` reads from stdin into a cell, and `.`
writes from a cell onto stdout. We need to call C functions for this: `putchar`
and `getchar`.

We need to declare these functions, as we did with `malloc` earlier:

{% highlight llvm %}
declare i32 @putchar(i32)
declare i32 @getchar()
{% endhighlight %}

To implement `,` call `getchar`, truncate it to a char, and write it
to the current cell. If you're not sure how to use
[LLVM's trunc instruction](http://llvm.org/docs/LangRef.html#trunc-to-instruction)
you can use Clang to generate examples.

{% highlight llvm %}
%cell_index = load i8* %cell_index_ptr
%cell_ptr = getelementptr i8* %cells, i8 %cell_index

%input_int = call i32 @getchar()
%input_byte = trunc i32 %input_int to i8
store i8 %input_byte, i8* %cell_ptr
{% endhighlight %}

`.` is the reverse: we read the cell, sign extend it, then call `putchar`.

{% highlight llvm %}
%cell_index = load i8* %cell_index_ptr
%cell_ptr = getelementptr i8* %cells, i8 %cell_index

%current_value = load i8* %cell_ptr
%current_value_int = sext i8 %current_value to i32
%dont_care = call i32 @putchar(i32 %current_value_int)
{% endhighlight %}
